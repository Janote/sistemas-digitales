00: 00700293
04: 00100313
08: 0062f333
0c: 00030463
10: fff28293
14: 4012d293



1)a

// addi 

000000000111 00000 000 00101 0010011


000000000111 00000 000 00101 0010011

Guarda el 7(valor inmediato) + lo que estaba en el registro 0 , que es cero. Entonces guarda en el registro 5 el 7.


b)

000000000001 00000 000 00110 0010011


000000000001 00000 000 00110 0010011

El registro 6 sera el resultado de sumar 0 + 1 , donde 1 es el valor inmediato y cero es por el registro zero;




c)0062f333

0000000 00110 00101 111 00110 0110011


0000000 00110 00101 111 00110 0110011

Guarda en el registro 6 ,la operacion logica bit a bit con el valor dentro del registro 6 que es 1 con el que 
esta en el registro 5, que es 7. Guarda en el registro 6 , el resultado de la operacion que es 1




0000 0000 0000 0000 0000 0000 0000 0000 0111 r5
0000 0000 0000 0000 0000 0000 0000 0000 0001 r6 
0000 0000 0000 0000 0000 0000 0000 0000 0001 r6 despues de la operacion







d)
00030463


0000000 00000 00110 000 01000 1100011 


desgloso el offset:

000000000100 : 4



Si el  valor del registro zero == registro 6 (que es falso),  el pc apunta a su valor actual mas el offset , que es 4.


Inmediato == offset: 00000000000100 = 4

entonces el pc apunta a la proxima instruccion si se cumple la condicion o no.



e)

// tipo inmediato;



111111111111 00101 000 00101 0010011


// instruccion addi

el registro destino (r5) , sera lo que vale el r5(que es siete) + el inmediato, que es 2^12 + 2^11 + 2^10 + 2^... + 2^0 . = 8197 ; va ser r5= 8198
esto lo hara sin importar si el registro 6 era igual  al registro cero, ya que el PC apuntaba all de todas formas.




f)


4012d293

SRAI

010000 000001 00101 101 00101 0010011
010000 000001 00101 101 00101 0010011





Va a guardar en el registro 5, el resultado de mover 1(por el shamt =1 ) posicion a la derecha el valor que tenia almacenado, que era 8198(decimal)

R5 : 0000000000000000001000000000011



Su mayor cifra significativa es el 1 , rellenara con 1' a la izquierda solo una vez porque el shamt == 1 

R5 : 100000000000000000100000000001;

r5 = 2147483647


2.
li a0,4228 	#carga el valor 4228 en registro a0
li a1,2114	#carga el valor 2214 en registro a1
jal ra, resta	#salto incondicional a resta y asigna ra a PC + 4 (en este caso 0x0000000C)
fin: beq zero, zero, fin	#en este ultimo tramo el programa cae en un loop infinito (pues 0 == 0)
resta: prologo: addi sp, sp,-4	#hago espacio en el stack para una palabra
sw ra,0(sp)		#cargo el ra en el espacio que creó la instrucción previa
sub a0,a0,a1		#guardo la resta a0 - a1 en a0
beq a0,zero,epilogo	#si a0 == 0 salto a epilogo	
sigo:jal ra, resta	#salto a resta y asigno ra a PC + 4 (0x0000002C)		
epilogo:lw ra, 0(sp)	#guardo en ra la ultima palabra insertada en el stack
addi sp, sp,4		#libero el espacio que ocupaba la ultima palabra insertada en el stack
ret			#vuelvo al ra

a) Posiciones de memoria de cada etiqueta:
fin 		0x0000000C
resta y prologo	0x00000010
sigo 		0x00000020
epilogo		0x00000024

b) Desplazamiento de llamadas a etiquetas:
La primera llamada a una etiqueta se hace en la instrucción "jal ra, resta".
De ahí se pasa a la instrucción inmediatamente siguiente (que es prologo y sus instrucciones).
En la primera iteración, a0 (4228) - a1 (2114) != 0 con lo cual "beq a0,zero,epilogo" no salta a epilogo y en cambio sigue en la etiqueta "sigo".
En "sigo", volvemos a resta y en esta iteracion a0 (2114) - a1 (2114) == 0 de manera que saltamos a "epilogo", se ejecuta el ret, volvemos a "epilogo" una vez más y 
el ra nos lleva a "fin" que, dado que zero == zero siempre va a ser cierto, se va a llamar a sí mismo continuamente.

c) Tanto li como addi precisan de inmediatos de 12 bits. Esto nos permite representar números con signo en un rango de -2048 a 2047 (o 100000000000 a 011111111111, en binario)

d) Para cargar numeros que exceden ese rango hace falta utilizar lui para cargar los 20 bits superiores y posteriormente cargar los 12 bits inferiores restantes con addi.

e) a1 se mantiene en 2114.

f) Al final, PC es 0x0000000C.

g) (Se asume que todos los valores siguientes están en hexa):
00 -> 04 -> 08 (salta a resta)-> 10 -> 14 -> 18 -> 1C (no se verifica a0 == zero) -> 20 (salta a resta)
-> 10 -> 14 -> 18 -> 1C (se verifica a0 == zero, por eso salta a epilogo) -> 24 -> 28 -> 2C (vuelve al ultimo ra insertado, es decir el 20 + 4)
-> 24 -> 28 -> 2C (vuelve al ultimo ra insertado, es decir el 08 + 4) -> 0C -> 0C -> ... -> 0C














