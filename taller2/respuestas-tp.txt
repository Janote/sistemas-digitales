                                     RESPUESTAS TP

1)A)  El circuito esta formado por 3 entradas donde cada una de ellas esta conectada con un buffer, este nos indicara cuando dejamos pasar el valor y cuando no, de esta forma podemos controlarel flujo de datos.
Haciendo logica combinatoria, podemos observar que cuando tenemos una entrada con un 0 y alguna de las otros dos con un 1, nos genera error.
Esto es ya que estan pasando distintos valores a nuestro output, que es Res.
Cuando ninguna esta prendida, res esta undefined , ya que no tenemos informacion sobre su valor anterior.
Cuando almenos uno de los buffers pasa 1, y los demas no pasan 0, de esa forma res = 1 .
res = 0 cuando pase lo mismo que para el  caso de 1 .

b)
- El valor rojo representa que hay un error, ya que estamos asignando en un mismo caso dos valores distintos a res.
- Cuando esta en azul , es que no esta pasando un valor.
-Cuando esta en verde, es que res = 1 .


c)
La regla que pondriamos es que cuando hay en una entrada un 1 , y nuestro buffer esta en 1 tambien, no puede pasar
que para el resto de entradas haya un 0 y el buffer sea 1.
Lo mismo para el caso del 0 : 
La regla que pondriamos es que cuando hay en una entrada un 0 , y nuestro buffer esta en 1 tambien, no puede pasar
que para el resto de entradas haya un 1 y el buffer sea 1.


d)
Las combinatorias basuras que consideramos en la materia son aquellas las cuales el clock(A/B/C_en) esta en 0 .

Las marcadas con una X son las basuras:

A A_en B B_en C C_en | Res
~~~~~~~~~~~~~~~~~~~~~~~~~~
0  0   0  0   0  0   |  - X
0  0   0  0   0  1   |  0 X
0  0   0  0   1  0   |  - X
0  0   0  0   1  1   |  1 X
0  0   0  1   0  0   |  0 X
0  0   0  1   0  1   |  0 X
0  0   0  1   1  0   |  0 X
0  0   0  1   1  1   |  ? X
0  0   1  0   0  0   |  - X
0  0   1  0   0  1   |  0 X
0  0   1  0   1  0   |  - X
0  0   1  0   1  1   |  1 X
0  0   1  1   0  0   |  1 X
0  0   1  1   0  1   |  ? X
0  0   1  1   1  0   |  1 X
0  0   1  1   1  1   |  1 X
0  1   0  0   0  0   |  0 X
0  1   0  0   0  1   |  0 X
0  1   0  0   1  0   |  0 X
0  1   0  0   1  1   |  ? X
0  1   0  1   0  0   |  0 X
0  1   0  1   0  1   |  0 
0  1   0  1   1  0   |  0 X
0  1   0  1   1  1   |  ? 
0  1   1  0   0  0   |  0 X
0  1   1  0   0  1   |  0 X
0  1   1  0   1  0   |  0 X
0  1   1  0   1  1   |  ? X
0  1   1  1   0  0   |  ? X
0  1   1  1   0  1   |  ? 
0  1   1  1   1  0   |  ? X
0  1   1  1   1  1   |  ? 
1  0   0  0   0  0   |  - X
1  0   0  0   0  1   |  0 X
1  0   0  0   1  0   |  - X
1  0   0  0   1  1   |  1 X
1  0   0  1   0  0   |  0 X
1  0   0  1   0  1   |  0 X
1  0   0  1   1  0   |  0 X
1  0   0  1   1  1   |  ? X
1  0   1  0   0  0   |  - X
1  0   1  0   0  1   |  0 X
1  0   1  0   1  0   |  - X
1  0   1  0   1  1   |  1 X
1  0   1  1   0  0   |  1 X
1  0   1  1   0  1   |  ? X
1  0   1  1   1  0   |  1 X
1  0   1  1   1  1   |  1 X
1  1   0  0   0  0   |  1 X
1  1   0  0   0  1   |  ? X
1  1   0  0   1  0   |  1 X
1  1   0  0   1  1   |  1 X
1  1   0  1   0  0   |  ? X
1  1   0  1   0  1   |  ? 
1  1   0  1   1  0   |  ? X
1  1   0  1   1  1   |  ? 
1  1   1  0   0  0   |  1 X
1  1   1  0   0  1   |  ? X
1  1   1  0   1  0   |  1 X
1  1   1  0   1  1   |  1 X
1  1   1  1   0  0   |  1 X
1  1   1  1   0  1   |  ? 
1  1   1  1   1  0   |  1 X
1  1   1  1   1  1   |  1 

2)

A) 
Las entradas que deben ser consdieradas como control son clk , w(enable)  , en_force_input , clk' y w' para el registro-entrada-salida restringido.
Las salidas son el Reg_output y el Reg_Debug

Reg_output: Representa la condicion en la cual en_out esta en 1 y el estado de Reg_Debug

Reg_Debug: Representa como funciona un flip-flop del tipo 'D' , almacenando valores dependiendo del clock y del dato de entrada.


2)b)

Secuencia: Vamos a partir del caso en que todos los inputs son 0.

Establezco un 1 en w.
en_force_input 1;
en_force_input 1;
clk en 1;


2)C)

Suponer para un valor: Pongo R0 en 1(mismos pasos que en el 2)b) Y todos los demas inputs estan en 0.



\\ CONSIGNAS \\ 
\\un valor arbitrario en R0, luego que este valor se transfiera a R1. \\


utilizo el writing mode en R1.


Pongo en 1 en_force_input Y force_input 


hago un flanco de bajada y luego de subida en el clock.

\\ Luego que el valor de R2 pase a R0 \\ 

desactivo modo escritura R1.

activo la escritura en R0

PONGO EN 0 en_force_input


hago un flanco de bajada y luego de subida en el clock.


\\ Finalmente el valor de R1 a R2. \\ 

desactivo modo escritura R0

activo modo escritura R2

en_force_input a 1;

hago un flanco de bajada y luego de subida en el clock.;


GENERALIZANDO: lo que podemos ver es que tenemos que tener muy en cuenta el Writing mode, ya que si no
prestamos atencion podemos sobreescribir valores y luego esto preste a confusiones.



